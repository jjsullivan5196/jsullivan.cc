<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-02-22 Sat 23:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Make software simple again</title>
<meta name="author" content="john" />
<meta name="generator" content="Org Mode" />
<style>
:root {
    --fg: #000000;
    --bg: #eeeeee;
    --midlight: #444444;
    --highlight: #ee4444;
}

* {
    font-family: sans;
}

html {
    min-height: 100%;
    border-left: solid var(--highlight) 15px;
}

body {
    margin: auto;
    padding: 25px;
    max-width: 48em;
}

body, body * {
    color: var(--fg);
    background-color: var(--bg);
}

a:visited {
    color: var(--midlight);
}

a {
    color: var(--highlight);
}

</style>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./"> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Make software simple again</h1>
<p>
There's a commentary section that follows the list, read it for
purpose/background on this article. If you have suggestions, please
contact me or send a
<a href="https://github.com/jjsullivan5196/jsullivan.cc/tree/master/therealsuckless.org">github
PR</a> for this page.
</p>

<div id="outline-container-the-list" class="outline-2">
<h2 id="the-list">The List</h2>
<div class="outline-text-2" id="text-the-list">
</div>
<div id="outline-container-consolidating-implementation-effort" class="outline-3">
<h3 id="consolidating-implementation-effort">Consolidating implementation effort</h3>
<div class="outline-text-3" id="text-consolidating-implementation-effort">
<p>
The following sections highlight ideas that make it simpler to create
and inspect software systems.
</p>
</div>

<div id="outline-container-fielding-et-al-architectural-styles-and-the-design-of-network-based-software-architectures" class="outline-4">
<h4 id="fielding-et-al-architectural-styles-and-the-design-of-network-based-software-architectures">Fielding et al, Architectural Styles and the Design of Network-based Software Architectures</h4>
<div class="outline-text-4" id="text-fielding-et-al-architectural-styles-and-the-design-of-network-based-software-architectures">
<ul class="org-ul">
<li><a href="https://ics.uci.edu/~fielding/pubs/dissertation/top.htm">https://ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></li>
</ul>

<p>
Roy Fielding's disseration on the design of networked applications and
RESTful architecture. Gives context to the design of modern hypermedia
systems, HTTP, the web and applications we build on top of it.
</p>
</div>
</div>

<div id="outline-container-htmx" class="outline-4">
<h4 id="htmx">htmx</h4>
<div class="outline-text-4" id="text-htmx">
<ul class="org-ul">
<li><a href="https://htmx.org/docs/">https://htmx.org/docs/</a></li>
</ul>

<p>
Library that implements a modern hypermedia client in any web browser,
rather than writing a different one every time you make a webapp.
</p>
</div>
</div>

<div id="outline-container-rich-hickey-on-repls" class="outline-4">
<h4 id="rich-hickey-on-repls">Rich Hickey on REPLs</h4>
<div class="outline-text-4" id="text-rich-hickey-on-repls">
<ul class="org-ul">
<li><a href="https://nextjournal.com/mk/rich-hickey-on-repls">https://nextjournal.com/mk/rich-hickey-on-repls</a></li>
</ul>

<p>
REPLs aren't just about evaluating code interactively, they're a
well-defined entrypoint for the programmer to modify and inspect a
system. The ceremony is well-organized and specifically tailored to this
purpose, you send data to the program, the program evaluates it, and you
get data back. Also see the linked talk by Nada Amin, which evaluates
this concept from the perspective of implementing languages.
</p>
</div>
</div>

<div id="outline-container-cosmopolitan-libc" class="outline-4">
<h4 id="cosmopolitan-libc">Cosmopolitan LibC</h4>
<div class="outline-text-4" id="text-cosmopolitan-libc">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=1ZTRb-2DZGs">https://www.youtube.com/watch?v=1ZTRb-2DZGs</a></li>
<li><a href="https://justine.lol/cosmopolitan/index.html">https://justine.lol/cosmopolitan/index.html</a></li>
<li><a href="https://redbean.dev/">https://redbean.dev/</a></li>
</ul>

<p>
Cosmo is a gargantuan effort to create a C library that can target
multiple platforms at once in a single binary. It has one abstraction
over the system layer that largely emulates the amd64 ABI for Linux,
meaning that most applications made for Linux can run natively on any
major operating system. It also bundles necessary functions for common
tasks like HTTP servers or multimedia manipulation. Redbean is a small
application server linked against cosmo that provides the equivalent of
a full LAMP stack in one program, one executable file that is your
entire application, with its code and database state.
</p>
</div>
</div>

<div id="outline-container-forth-metacompilation" class="outline-4">
<h4 id="forth-metacompilation">Forth metacompilation</h4>
<div class="outline-text-4" id="text-forth-metacompilation">
<ul class="org-ul">
<li><a href="https://www.ultratechnology.com/meta.html#minmeta">https://www.ultratechnology.com/meta.html#minmeta</a></li>
<li><a href="https://arduino-forth.com/article/FORTH_metacompilation_intro">https://arduino-forth.com/article/FORTH_metacompilation_intro</a></li>
<li><a href="https://pygmy.utoh.org/pygmyforth.html">https://pygmy.utoh.org/pygmyforth.html</a></li>
</ul>

<p>
Forth is a very small programming language, phrased more as an abstract
stack machine. The machine executes words, which are procedures that
manipulate data on a shared stack. Typically the machine is defined in
terms of primitive words, implemented in native machine code. Forth
metacompilers allow for this abstract machine to be defined in Forth
itself, creating a very tight loop for designing other Forth systems.
</p>
</div>
</div>

<div id="outline-container-bootstrapping-the-forth-language-from-a-3-instruction-interpreter" class="outline-4">
<h4 id="bootstrapping-the-forth-language-from-a-3-instruction-interpreter">Bootstrapping the Forth language from a 3-instruction interpreter</h4>
<div class="outline-text-4" id="text-bootstrapping-the-forth-language-from-a-3-instruction-interpreter">
<ul class="org-ul">
<li><a href="https://pygmy.utoh.org/3ins4th.html">https://pygmy.utoh.org/3ins4th.html</a></li>
</ul>

<p>
From Frank Sergeant. Essentially describes a generic protocol for a
<a href="https://en.wikipedia.org/wiki/Machine_code_monitor">machine code
monitor</a> over a serial port. Using only peek, poke, and essentially a
CALL instruction, a full Forth machine can be implemented on the target
from any programming language.
</p>
</div>
</div>
</div>

<div id="outline-container-prior-art" class="outline-3">
<h3 id="prior-art">Prior art</h3>
<div class="outline-text-3" id="text-prior-art">
<p>
Well-executed attempts at creating a cohesive software development
system
</p>
</div>

<div id="outline-container-smalltalk-80-on-the-xerox-alto" class="outline-4">
<h4 id="smalltalk-80-on-the-xerox-alto">Smalltalk-80 on the Xerox Alto</h4>
<div class="outline-text-4" id="text-smalltalk-80-on-the-xerox-alto">
<ul class="org-ul">
<li><a href="https://youtu.be/uknEhXyZgsg?si=69rb8E0Lljtr-w1E">https://youtu.be/uknEhXyZgsg?si=69rb8E0Lljtr-w1E</a></li>
<li><a href="https://computerhistory.org/blog/smalltalk-at-50/">https://computerhistory.org/blog/smalltalk-at-50/</a></li>
</ul>
</div>
</div>

<div id="outline-container-hypercard" class="outline-4">
<h4 id="hypercard">Hypercard!</h4>
<div class="outline-text-4" id="text-hypercard">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=2K1C5BZKP3I">https://www.youtube.com/watch?v=2K1C5BZKP3I</a></li>
</ul>
</div>
</div>

<div id="outline-container-the-self-programming-language-java-and-javascripts-dad" class="outline-4">
<h4 id="the-self-programming-language-java-and-javascripts-dad">The Self Programming Language (Java and Javascript's Dad)</h4>
<div class="outline-text-4" id="text-the-self-programming-language-java-and-javascripts-dad">
<ul class="org-ul">
<li><a href="https://selflanguage.org/">https://selflanguage.org/</a></li>
</ul>

<p>
Self was the breeding ground for what eventually became the JVM platform
and Javascript's prototypal object system. It was a pioneer in language
VM implementation, aiming to create an entire development environment
and runtime in the same programming language.
</p>
</div>
</div>

<div id="outline-container-genera-and-s-graphics" class="outline-4">
<h4 id="genera-and-s-graphics">Genera and S-Graphics</h4>
<div class="outline-text-4" id="text-genera-and-s-graphics">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=gV5obrYaogU">https://www.youtube.com/watch?v=gV5obrYaogU</a></li>
</ul>

<p>
A complete 3D and compositing solution all running on a Symbolics Lisp
Machine. Later became the software basis for SGI and its many licensed
development kits.
</p>
</div>
</div>

<div id="outline-container-steel-bank-common-lisp" class="outline-4">
<h4 id="steel-bank-common-lisp">Steel Bank Common Lisp</h4>
<div class="outline-text-4" id="text-steel-bank-common-lisp">
<ul class="org-ul">
<li><a href="https://www.sbcl.org/porting.html">https://www.sbcl.org/porting.html</a></li>
</ul>

<p>
Common Lisp implementation written in itself, build process can almost
skip a C compiler.
</p>
</div>
</div>

<div id="outline-container-oberon" class="outline-4">
<h4 id="oberon">Oberon</h4>
<div class="outline-text-4" id="text-oberon">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Oberon_(operating_system)">https://en.wikipedia.org/wiki/Oberon_(operating_system)</a></li>
<li><a href="https://www.youtube.com/watch?v=OJGnpmnXR5w">https://www.youtube.com/watch?v=OJGnpmnXR5w</a></li>
</ul>

<p>
A complete operating system implemented in a Pascal-like language. All
interactions with the system are done thru rich text documents that can
embed programs and various objects. Running code is as simple as
clicking a hyperlink.
</p>
</div>
</div>

<div id="outline-container-btron" class="outline-4">
<h4 id="btron">BTRON</h4>
<div class="outline-text-4" id="text-btron">
<ul class="org-ul">
<li><a href="https://youtu.be/7RNbIEJvjUA?si=rYcdjt8D22oHGokS&amp;t=1505">https://youtu.be/7RNbIEJvjUA?si=rYcdjt8D22oHGokS&amp;t=1505</a></li>
<li><a href="https://en.wikipedia.org/wiki/BTRON">https://en.wikipedia.org/wiki/BTRON</a></li>
</ul>

<p>
A core component of Japan's TRON computer platform, was meant to be a
programming environment working on the scale of the web. All resources
were presented as inspectable objects, much like Smalltalk. These could
represent simple data, hypermedia documents, remote machines, or
collections of other objects.
</p>
</div>
</div>

<div id="outline-container-rebol" class="outline-4">
<h4 id="rebol">Rebol</h4>
<div class="outline-text-4" id="text-rebol">
<ul class="org-ul">
<li><a href="http://www.rebol.com/what-rebol.html">http://www.rebol.com/what-rebol.html</a></li>
</ul>
</div>
</div>

<div id="outline-container-pygmyforth" class="outline-4">
<h4 id="pygmyforth">PygmyForth</h4>
<div class="outline-text-4" id="text-pygmyforth">
<ul class="org-ul">
<li><a href="https://pygmy.utoh.org/pygmyforth.html">https://pygmy.utoh.org/pygmyforth.html</a></li>
</ul>

<p>
A complete Forth system for DOS that can recompile itself. Includes
facilities for interactive development and debugging.
</p>
</div>
</div>

<div id="outline-container-smithforth" class="outline-4">
<h4 id="smithforth">SmithForth</h4>
<div class="outline-text-4" id="text-smithforth">
<ul class="org-ul">
<li><a href="https://dacvs.neocities.org/SF/">https://dacvs.neocities.org/SF/</a></li>
<li><a href="https://www.youtube.com/watch?v=9MSJGzYELBA">https://www.youtube.com/watch?v=9MSJGzYELBA</a></li>
</ul>

<p>
A Forth 2012 compliant system implemented in legible amd64 machine code.
The interpreter bootstraps from a byte-delimited read-protocol, which
defines the primitive Forth words directly in machine code. After
startup, a full Forth system can be used to compile and run code
interactively.
</p>
</div>
</div>

<div id="outline-container-jonesforth" class="outline-4">
<h4 id="jonesforth">JonesForth</h4>
<div class="outline-text-4" id="text-jonesforth">
<ul class="org-ul">
<li><a href="https://github.com/nornagon/jonesforth/blob/master/jonesforth.S">https://github.com/nornagon/jonesforth/blob/master/jonesforth.S</a></li>
</ul>

<p>
Forth implemented in x86 assembler, complete with inline documentation
and diagrams explaining how it works.
</p>
</div>
</div>
</div>

<div id="outline-container-cool-stuff-happening-today" class="outline-3">
<h3 id="cool-stuff-happening-today">Cool stuff happening today</h3>
<div class="outline-text-3" id="text-cool-stuff-happening-today">
</div>
<div id="outline-container-graalvm-and-self-hosted-java" class="outline-4">
<h4 id="graalvm-and-self-hosted-java">GraalVM and self-hosted Java</h4>
<div class="outline-text-4" id="text-graalvm-and-self-hosted-java">
<ul class="org-ul">
<li><a href="https://www.graalvm.org/latest/reference-manual/java-on-truffle/">https://www.graalvm.org/latest/reference-manual/java-on-truffle/</a></li>
</ul>
</div>
</div>

<div id="outline-container-development-of-the-uefi-ecosystem" class="outline-4">
<h4 id="development-of-the-uefi-ecosystem">Development of the UEFI ecosystem</h4>
<div class="outline-text-4" id="text-development-of-the-uefi-ecosystem">
<ul class="org-ul">
<li><a href="https://stackoverflow.com/a/53057494">https://stackoverflow.com/a/53057494</a></li>
<li><a href="https://www.linuxboot.org/">https://www.linuxboot.org/</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-unix-haters" class="outline-3">
<h3 id="unix-haters">Unix haters</h3>
<div class="outline-text-3" id="text-unix-haters">
<p>
And they're right
</p>
</div>

<div id="outline-container-stop-writing-dead-programs" class="outline-4">
<h4 id="stop-writing-dead-programs">Stop Writing Dead Programs</h4>
<div class="outline-text-4" id="text-stop-writing-dead-programs">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=8Ab3ArE8W3s">https://www.youtube.com/watch?v=8Ab3ArE8W3s</a></li>
</ul>
</div>
</div>

<div id="outline-container-replacing-the-unix-tradition" class="outline-4">
<h4 id="replacing-the-unix-tradition">Replacing the UNIX tradition</h4>
<div class="outline-text-4" id="text-replacing-the-unix-tradition">
<ul class="org-ul">
<li><a href="https://youtu.be/L9v4Mg8wi4U">https://youtu.be/L9v4Mg8wi4U</a></li>
</ul>
</div>
</div>

<div id="outline-container-more-powerful-primitives" class="outline-4">
<h4 id="more-powerful-primitives">More powerful primitives</h4>
<div class="outline-text-4" id="text-more-powerful-primitives">
<ul class="org-ul">
<li><a href="https://dercuano.github.io/notes/powerful-primitives.html">https://dercuano.github.io/notes/powerful-primitives.html</a></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-my-bad-ill-advised-opinions" class="outline-2">
<h2 id="my-bad-ill-advised-opinions">My bad, ill-advised opinions</h2>
<div class="outline-text-2" id="text-my-bad-ill-advised-opinions">
<p>
This article is an annotated reading list that tracks tools for better
understanding how software is
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">made</a> and
<a href="https://en.wikipedia.org/wiki/Turing_machine">run</a> on
<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">machines</a>. It
will be loaded with a lot of my own wacky opinions of how bad software
and computers are, since it is my main motivation for constantly
looking for more of these materials.
</p>

<p>
More specifically, I want to understand why the engineering distance
between a machine and the practical applications it performs is so
inordinately large. We have excellent, high-level programming
languages with appropriate primitives to build world-scale systems,
but God forbid you want to talk to a
<a href="https://gist.github.com/Overv/7ac07356037592a121225172d7d78f2d">graphics</a>
<a href="https://youtu.be/_36yNWw_07g?si=ne3IAwWmQEcEk6e3">device</a> and have
it do a cool trick you just thought up, or create your own
<a href="https://llvm.org/docs/GettingStarted.html">programming language</a>,
or any number of applications that involve negotiating with some
platform.
</p>

<p>
Smalltalk, all the way back in the 1980s, did solve all the problems
related to bootstrapping a complete programming system from bare
metal, and you could inspect any layer of that solution with the same
exact tools you use to write applications. Why can't we do that today?
Why can't we create a closed abstraction of a machine that any
platform or language can use?
</p>

<p>
I lay the blame with our development tools being inadequate for
understanding a complete system as a whole, from hardware &amp; platforms
to the software that runs on them. Any programmer should be able to
spend an afternoon in any programming language and be able to have a
small kernel program that can file your taxes and send HTTP requests
on nearly anything that can run code. However, we often get stuck in
what is the right language not for the application we are making, but
rather how this language can eventually target some CPU, operating
system, VM hypervisor, container framework, web browser, game console,
and so on.  Even when you do have merely adequate tools for
development, they often grow legs and run far away from your language
of choice, ask you to suffer hours of tutorials or documentation that
doesn't generalize, or bring
<a href="https://github.com/emacs-mirror/emacs">all their 50+ year old
friends</a> to give you some light reading.
</p>

<p>
Considering our platform is a fine problem to have, but in the end it
shouldn't be something that restricts our ability to use the right
tool for the problem we're trying to solve. Platforms offer us
primitives to run code, languages arrange those primitives into useful
tools for solving problems. Programming languages should offer us the
ability to solve both our application and platform-related problems in
a generic way. Despite this, we settle for
<a href="https://en.wikipedia.org/wiki/Worse_is_better">worse is better</a> and
have bespoke, cryptic and non-portable solutions for abstracting over
platforms. See the demand for win32 emulation, Valve basically
adopting the WINE project, the C programming language being unable to
die, and the success of Docker for evidence of platforms being more
than platforms.
</p>

<p>
Even the <a href="https://en.wikipedia.org/wiki/GraphQL">conceptual</a>
<a href="https://www.destroyallsoftware.com/talks/wat">machines</a> we build on
top of the real ones don't make our programs easier to
comprehend. Often they ignore
<a href="https://en.wikipedia.org/wiki/Self_(programming_language)">years</a>
of research work, or they haphazardly cherry pick features for some
particular reason (often not good reasons) to the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">detriment</a>
of the overall system being transparent to the person who works with
it.
</p>

<p>
I enjoy masochistically pretending I can do something about all of
this, so I spend a lot of time messing with compilers and other such
tools to see how we can simplify the process of making great
applications. This list documents some of the resources I've collected
to gain some insight on this issue and prior attempts at making better
tools for software development.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2023-09-01 Fri 00:00</p>
<p class="author">Author: john</p>
<p class="date">Created: 2025-02-22 Sat 23:18</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
